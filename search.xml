<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[盛最多水的容器(算法)]]></title>
    <url>%2F%E7%AE%97%E6%B3%95-leetcode%2F%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[盛最多水的容器问题描述：给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 样例Code12输入: [1,8,6,2,5,4,8,3,7]输出: 49 解题思路解法一：暴力法遍历整个数组，保存面积最大 ，最容易解出。不做详细说明 复杂度：时O(n*n) 空O(1) java1234567891011121314151617class Solution &#123; public int maxArea(int[] height) &#123; int res = 0; int length = height.length; for(int i=0; i&lt; length-1; i++)&#123; for(int j=i+1; j&lt;=length-1; j++)&#123; if((j - i) * min(height[i],height[j]) &gt; res)&#123; res = (j - i) * min(height[i],height[j]); &#125; &#125; &#125; return res; &#125; private static int min(int a,int b)&#123; return a &lt;= b?a:b; &#125;&#125; 解法二：双指针遍历定义两个指针，分别置于数组第一个元素和最后一个元素，每次记录这两个指针围成的矩形的面积（只需记录最大面积），由于矩形的宽度取决于最短的那个指针，所以在移动指针时，每次将短的指针向长的指针移动，当两个指针相遇的时候，遍历结束。先给出代码，之后证明双指针获得的数组是正确的 java1234567891011121314class Solution&#123; public int maxArea(int[]height)&#123; int res = 0,lp = 0,rp = height.length - 1; while(lp &lt; rp)&#123; res = Math.max(res,(rp - lp) * Math.min(height[lp],height[rp])); if(height[lp] &lt; height[rp])&#123; lp++; &#125;else&#123; rp--; &#125; &#125; return res; &#125;&#125; 双指针只需遍历一次就可得出结果所以，其复杂度为：时O(n) 空O(1) 利用反证法证明（来源leetcode）Code1234567 | | | | .....|............|.....____________________________ m n 如图，若m,n之间的面积为最大面积。 双指针方法的规律是：每次都会向内移动偏矮的指针（可观察案例）。要证明两个指针一定会移动到m和n位置，只需证明： m左侧的指针点等于或矮于n，n右侧指针等于或矮于m。 假设m左侧有一个点p，高度高于n. Code12345678 | | | | | | | |.....|.......|.......|________________________ p m n 因为 ： areaMN = (n - m)* max(arr[m],arr[n]) areaPN = (n - p)* max(arr[p],arr[n]) 又： &gt;(n - p) &gt; (n - m) &gt; &gt;max(arr[m],arr[n]) &lt; max(arr[p],arr[n])故： &gt;areaMN &lt; areaPN因此假设不成立，即m左侧的点不高于n。同理可证n右侧的点不低于m]]></content>
      <categories>
        <category>算法,leetcode</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈springcloud下]]></title>
    <url>%2Fspringcloud%2F%E6%B5%85%E8%B0%88springcloud%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[浅谈springcloud下Feign 什么是Feign Feign是Netflix提供的一个声明式、模板化的Web Service客户端，它简化了开发者编写Web服务客户都的操作，开发者可以通过简单的接口和注解来调用HTTP API，Spring Cloud Feign整合了Ribbon和Hystrix，具有可插拔、基于注解、负载均衡、服务熔断等一系列的功能。 相较于Ribbon+RestTemplate的方式，Feign大大简化了代码的开发，Feign支持多种注解，包括Feign注解，JAX-RS注解、SpringMvc注解等。Feign是基于Ribbon实现的。 创建Module、添加Pom.xml xml123456789101112&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 yaml1234567891011server: port: 8050spring: application: name: feigneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 创建启动类 java1234567891011121314package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClientspublic class FeignApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(FeignApplication.class,args); &#125;&#125; 注解说明： ​ @EnableFeignClients: 声明该类是一个Feign客户端 创建Student实体类 创建声明式接口 java123456789101112131415package com.crescentd.repository;import com.crescentd.entity.Student;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.Collection;@FeignClient(value = "provider")public interface FeignClients &#123; @GetMapping("/student/findAll") public Collection&lt;Student&gt; findAll(); @GetMapping("/student/index") public String index();&#125; 注解说明： ​ @FeignClient: 声明式调用接口 value: 要调用的服务名称 &gt; 属性说明; &gt; &gt; - name：指定FeignClient的名称，如果项目使用了Ribbon，name属性会作为微服务的名称，用于服务发现 &gt; - url: url一般用于调试，可以手动指定@FeignClient调用的地址 &gt; - decode404:当发生http 404错误时，如果该字段位true，会调用decoder进行解码，否则抛出FeignException &gt; - configuration: Feign配置类，可以自定义Feign的Encoder、Decoder、LogLevel、Contract &gt; - fallback: 定义容错的处理类，当调用远程接口失败或超时时，会调用对应接口的容错逻辑，fallback指定的类必须实现@FeignClient标记的接口 &gt; - fallbackFactory: 工厂类，用于生成fallback类示例，通过这个属性我们可以实现每个接口通用的容错逻辑，减少重复的代码 创建Controller java12345678910111213141516171819202122232425262728package com.crescentd.controller;import com.crescentd.entity.Student;import com.crescentd.repository.FeignClients;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Collection;@RestController@RequestMapping("/feign")public class FeignController &#123; @Autowired private FeignClients feignClients; @GetMapping("/findAll") public Collection&lt;Student&gt; findAll()&#123; return feignClients.findAll(); &#125; @GetMapping("/index") public String index()&#123; return feignClients.index(); &#125;&#125; 服务熔断，在配置文件中添加熔断机制 yaml123feign: hystrix: enabled: true 创建FeignClients的实现类，使用@Component 注解将FeignError注入到IOC容器中 java1234567891011121314151617181920package com.crescentd.repository.impl;import com.crescentd.entity.Student;import com.crescentd.repository.FeignClients;import org.springframework.stereotype.Component;import java.util.Collection;@Componentpublic class FeignError implements FeignClients &#123; @Override public Collection&lt;Student&gt; findAll() &#123; return null; &#125; @Override public String index() &#123; return "服务器维护中，敬请期待！"; &#125;&#125; 在声明式接口@FeignClient 注解中添加fallback 属性 java12345678910111213141516package com.crescentd.repository;import com.crescentd.entity.Student;import com.crescentd.repository.impl.FeignError;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.Collection;@FeignClient(value = "provider",fallback = FeignError.class)public interface FeignClients &#123; @GetMapping("/student/findAll") public Collection&lt;Student&gt; findAll(); @GetMapping("/student/index") public String index();&#125; Hystrix 容错机制 什么是Hystrix 在不改变各个微服务调用关系的前提下，针对错误情况进行预先处理 设计原则 1、服务隔离机制 2、服务降级机制 3、熔断机制 4、提供实时的监控和报警 5、提供实时的配置修改功能 Hystrix数据监控需要结合Spring Cloud Actuator来使用，Actuator提供了对服务的健康监控、数据统计，可以通过hystrix.stream来获取监控的请求数据，提供了可视化的监控界面 创建Module、添加Pom依赖 xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加配置文件 yaml12345678910111213141516171819server: port: 8060spring: application: name: hystrixeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: truefeign: hystrix: enabled: truemanagement: endpoints: web: exposure: include: 'hystrix.stream' 属性说明： ​ @management.endpoint.web.exposure.include: 监控暴露的节点 创建启动类 java1234567891011121314151617package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableFeignClients@EnableCircuitBreaker@EnableHystrixDashboardpublic class HystrixApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixApplication.class,args); &#125;&#125; 注解说明： ​ @EnableCircuitBreaker: 声明启用数据监控 ​ @EnableHystrixDashboard: 声明启用可视化数据监控 创建实体和controller java1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.crescentd.repository;import com.crescentd.entity.Student;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.Collection;@FeignClient(value = "provider")public interface FeignClients &#123; @GetMapping("/student/findAll") public Collection&lt;Student&gt; findAll(); @GetMapping("/student/index") public String index();&#125;package com.crescentd.controller;import com.crescentd.entity.Student;import com.crescentd.repository.FeignClients;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Collection;@RestController@RequestMapping("/hystrix")public class HystrixController &#123; @Autowired private FeignClients feignClients; @GetMapping("/findAll") public Collection&lt;Student&gt; findAll()&#123; return feignClients.findAll(); &#125; @GetMapping("/index") public String index()&#123; return feignClients.index(); &#125;&#125; 启动成功后，访问http://localhost:8060/actuator/hystrix.stream 可以监控到请求的数据 访问http://localhost:8060/hystrix 可以看到可视化的监控界面，输入要监控的地址节点即可看到节点的可视化数据监控 spring cloud的配置中心Spring Cloud Config ，通过服务端可以为多个客户端提供配置服务，Spring Cloud Config可以将本地，也可以将配置文件存储到远程git仓库，创建Config Server，通过它管理所有的配置文件 本地文件系统 创建Maven工程，添加Pom.xml xml1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加配置文件 yaml123456789101112server: port: 8762spring: application: name: nativeconfigserver profiles: active: native cloud: config: server: native: search-locations: classpath:/shared 属性说明： ​ spring.profiles.active: 配置文件的获取方式 ​ spring.cloud.config.server.native.search-locations: 本地配置文件的存放路径 在resources 路径下创建shared文件夹，并在此目录下创建configclient-dev.yml文件 yml123server: port: 8070foo: foo version 1 创建启动类 java12345678910111213package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.config.server.EnableConfigServer;@SpringBootApplication@EnableConfigServerpublic class ConfigServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ConfigServerApplication.class,args); &#125;&#125; 注解说明： ​ @EnableConfigServer: 声明配置中心 创建客户端读取本地配置中心的配置文件 创建Maven工程 xml1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件 yaml123456789spring: application: name: configclient profiles: active: dev cloud: config: uri: http://localhost:8762 fail-fast: true 属性说明： ​ spring.cloud.config.uri: 本地Config Server的访问路径 ​ spring.cloud.config.fail-fast: 设置客户端优先判断Config Server获取是否正常 通过spring.application.name和spring.profiles.active 拼接目标配置的文件名，configclient-dev.yml，去Config Server中查找该文件 创建启动类 java1234567891011package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class NativeConfigClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(NativeConfigClientApplication.class,args); &#125;&#125; 创建controller验证 java12345678910111213141516171819202122package com.crescentd.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping("/native")public class NativeConfigController &#123; @Value("$&#123;server.port&#125;") private int port; @Value("$&#123;foo&#125;") private String version; @GetMapping("/index") public String index()&#123; return this.port + "-" + this.version; &#125;&#125; 其实在启动的时候就能看到读取的端口和版本信息 Spring Cloud Server的远程配置 创建配置文件，上次至Github xml123456789server: port: 8070spring: application: name: remoteconfigclienteureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 创建工程同上 创建配置文件 yaml123456789101112131415161718server: port: 8888spring: application: name: remoteconfigserver cloud: config: server: git: uri: 自己仓库的地址 search-paths: config username: 自己的账号 password: 自己的密码 label: mastereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 创建启动类同上 客户端配置文件 yaml123456789101112spring: cloud: config: name: remoteconfigclient label: master discovery: enabled: true service-id: remoteconfigservereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ 属性说明： ​ spring.cloud.config.name: 当前服务注册在Eureka Server上的名称，与远程仓库的配置文件名对应 ​ spring.cloud.config.label: git仓库的一个分支 ​ spring.cloud.config.discovery.enabled: 是否开启config服务发现 ​ spring.cloud.config.discovery.service-id: 配置中心在注册中心的名称]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈spring cloud中]]></title>
    <url>%2Fspringcloud%2F%E6%B5%85%E8%B0%88springcloud%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[浅谈spring cloud中Ribbon 负载均衡 什么是Ribbon？ Spring Cloud Ribbon是一个负载均衡解决方案，Ribbon是Netflix发布的负载均衡器，Spring Cloud Ribbon是基于Netflix Ribbon实现的，是一个用于对HTTP请求进行控制的负载均衡客户端。 在注册中心对Ribbon进行注册之后，Ribbon就可以基于某种负载均衡算法，如轮询、随机、加权轮询、加权随机等自动帮助消费者调用接口，开发者也可以根据具体需求自定义Ribbon负载均衡树算法。实际开发中，Spring Cloud Ribbon 需要结合Spring Cloud Eureka来使用，Eureka Server 提供所有可以调用的服务提供者列表，Ribbon基于特定的负载均衡算法从这些服务提供者中选择要调用的具体实例。 创建Module工程，添加pom依赖 xml1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 添加配置文件 yml1234567891011server: port: 8040spring: application: name: ribboneureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 添加启动类 java123456789101112131415161718192021package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplicationpublic class RibbonApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RibbonApplication.class,args); &#125; @Bean @LoadBalanced public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 注解说明：@LoadBalanced : 声明一个基于Ribbon的负载均衡 编写controller java12345678910111213141516171819202122232425262728package com.crescentd.controller;import com.crescentd.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;import java.util.Collection;@RestController@RequestMapping("/ribbon")public class RibbonController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("/findAll") public Collection&lt;Student&gt; findAll()&#123; return restTemplate.getForEntity("http://provider/student/findAll",Collection.class).getBody(); &#125; @GetMapping("/index") public String index()&#123; return restTemplate.getForObject("http://provider/student/index",String.class); &#125;&#125; 启动与Zuul 的负载均衡相同 通过自定义注解来了解负载均衡注解@LoadBalanced 工作流程 自定义负载均衡注解@MyLoadBalanced java1234567891011package com.crescentd.interceptor;import org.springframework.beans.factory.annotation.Qualifier;import java.lang.annotation.*;@Target(&#123;ElementType.FIELD,ElementType.PARAMETER,ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Qualifierpublic @interface MyLoadBanlaced &#123;&#125; 注解说明： ​ @Target: 用于描述注解的使用范围（FIELD：描述域、PARAMETER：描述参数、METHOD：描述方法） ​ @Retention: 用于描述被定义注解的生命周期（SOURCE：源文件中有效、CLASS：class文件中有效、 RUNTIME：运行时有效） ​ @Documented: 表明被定义注解应该被javadoc工具记录 ​ @Qualifier: 用来限定那个类应该被注入 ​ @Inherited: 允许子类继承父类的注解 自定义拦截器 java1234567891011121314151617181920212223242526272829303132333435363738package com.crescentd.interceptor;import org.springframework.cloud.client.loadbalancer.LoadBalancerClient;import org.springframework.cloud.client.loadbalancer.LoadBalancerRequestFactory;import org.springframework.http.HttpRequest;import org.springframework.http.client.ClientHttpRequestExecution;import org.springframework.http.client.ClientHttpRequestInterceptor;import org.springframework.http.client.ClientHttpResponse;import org.springframework.util.Assert;import java.io.IOException;import java.net.URI;public class MyLoadBalancerInterceptor implements ClientHttpRequestInterceptor&#123; private LoadBalancerClient loadBalancer; private LoadBalancerRequestFactory requestFactory; public MyLoadBalancerInterceptor(LoadBalancerClient loadBalancer,LoadBalancerRequestFactory requestFactory)&#123; this.loadBalancer = loadBalancer; this.requestFactory = requestFactory; &#125; public MyLoadBalancerInterceptor(LoadBalancerClient loadBalancer)&#123; this(loadBalancer,new LoadBalancerRequestFactory(loadBalancer)); &#125; @Override public ClientHttpResponse intercept(final HttpRequest httpRequest,final byte[] bytes, final ClientHttpRequestExecution clientHttpRequestExecution) throws IOException &#123; final URI originUri = httpRequest.getURI(); String serviceName = originUri.getHost(); System.out.println("进入自定义的拦截器中："+serviceName); Assert.state(serviceName != null,"Request URI does not contain a valid hostname:" + originUri); return this.loadBalancer.execute(serviceName,requestFactory.createRequest(httpRequest,bytes,clientHttpRequestExecution)); &#125;&#125; 定义一个配置类，给RestTemplate注入上面的拦截器 java12345678910111213141516171819202122232425262728293031323334353637383940package com.crescentd.interceptor;import org.springframework.beans.factory.SmartInitializingSingleton;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.client.loadbalancer.LoadBalancerClient;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.ClientHttpRequestInterceptor;import org.springframework.web.client.RestTemplate;import java.util.ArrayList;import java.util.Collections;import java.util.List;@Configurationpublic class MyLoadBanlacedAutoConfiguration &#123; @MyLoadBanlaced @Autowired(required = false) private List&lt;RestTemplate&gt; restTemplates = Collections.emptyList(); @Bean public MyLoadBalancerInterceptor myLoadBalancerInterceptor(LoadBalancerClient loadBalancerClient)&#123; return new MyLoadBalancerInterceptor(loadBalancerClient); &#125; @Bean public SmartInitializingSingleton myLoadBalancedRestTemplateInitializer(LoadBalancerClient loadBalancerClient)&#123; return new SmartInitializingSingleton() &#123; @Override public void afterSingletonsInstantiated() &#123; for (RestTemplate restTemplate : MyLoadBanlacedAutoConfiguration.this.restTemplates)&#123; List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList&lt;&gt;(restTemplate.getInterceptors()); list.add(myLoadBalancerInterceptor(loadBalancerClient)); restTemplate.setInterceptors(list); &#125; &#125; &#125;; &#125;&#125; 将RibbonApplication 启动类中的获取RestTemplate 实例上的@LoadBalanced 换成@MyLoadBalanced ，运行启动类，访问以上的接口信息。通过控制台打印信息”进入自定义的拦截器provider”，说明自定义注解生效 贴一下@LoadBalanced 注解源码 LoadBalanced 拦截注入源码 java12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.cloud.client.loadbalancer;import java.util.ArrayList;import java.util.Collections;import java.util.Iterator;import java.util.List;import java.util.function.Consumer;import org.springframework.beans.factory.ObjectProvider;import org.springframework.beans.factory.SmartInitializingSingleton;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingClass;import org.springframework.boot.context.properties.EnableConfigurationProperties;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.http.client.ClientHttpRequestInterceptor;import org.springframework.retry.support.RetryTemplate;import org.springframework.web.client.RestTemplate;@Configuration@ConditionalOnClass(&#123;RestTemplate.class&#125;)@ConditionalOnBean(&#123;LoadBalancerClient.class&#125;)@EnableConfigurationProperties(&#123;LoadBalancerRetryProperties.class&#125;)public class LoadBalancerAutoConfiguration &#123; @LoadBalanced @Autowired( required = false ) private List&lt;RestTemplate&gt; restTemplates = Collections.emptyList(); @Autowired( required = false ) private List&lt;LoadBalancerRequestTransformer&gt; transformers = Collections.emptyList(); public LoadBalancerAutoConfiguration() &#123; &#125; @Bean public SmartInitializingSingleton loadBalancedRestTemplateInitializerDeprecated(ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers) &#123; return () -&gt; &#123; restTemplateCustomizers.ifAvailable((customizers) -&gt; &#123; Iterator var2 = this.restTemplates.iterator(); while(var2.hasNext()) &#123; RestTemplate restTemplate = (RestTemplate)var2.next(); Iterator var4 = customizers.iterator(); while(var4.hasNext()) &#123; RestTemplateCustomizer customizer = (RestTemplateCustomizer)var4.next(); customizer.customize(restTemplate); &#125; &#125; &#125;); &#125;; &#125; @Configuration @ConditionalOnMissingClass(&#123;"org.springframework.retry.support.RetryTemplate"&#125;) static class LoadBalancerInterceptorConfig &#123; LoadBalancerInterceptorConfig() &#123; &#125; @Bean public LoadBalancerInterceptor ribbonInterceptor(LoadBalancerClient loadBalancerClient, LoadBalancerRequestFactory requestFactory) &#123; return new LoadBalancerInterceptor(loadBalancerClient, requestFactory); &#125; @Bean @ConditionalOnMissingBean public RestTemplateCustomizer restTemplateCustomizer(LoadBalancerInterceptor loadBalancerInterceptor) &#123; return (restTemplate) -&gt; &#123; List&lt;ClientHttpRequestInterceptor&gt; list = new ArrayList(restTemplate.getInterceptors()); list.add(loadBalancerInterceptor); restTemplate.setInterceptors(list); &#125;; &#125; &#125;&#125; 所在拦截器源码 java1234567891011121314151617181920212223242526272829303132333435//// Source code recreated from a .class file by IntelliJ IDEA// (powered by Fernflower decompiler)//package org.springframework.cloud.client.loadbalancer;import java.io.IOException;import java.net.URI;import org.springframework.http.HttpRequest;import org.springframework.http.client.ClientHttpRequestExecution;import org.springframework.http.client.ClientHttpRequestInterceptor;import org.springframework.http.client.ClientHttpResponse;import org.springframework.util.Assert;public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor &#123; private LoadBalancerClient loadBalancer; private LoadBalancerRequestFactory requestFactory; public LoadBalancerInterceptor(LoadBalancerClient loadBalancer, LoadBalancerRequestFactory requestFactory) &#123; this.loadBalancer = loadBalancer; this.requestFactory = requestFactory; &#125; public LoadBalancerInterceptor(LoadBalancerClient loadBalancer) &#123; this(loadBalancer, new LoadBalancerRequestFactory(loadBalancer)); &#125; public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException &#123; URI originalUri = request.getURI(); String serviceName = originalUri.getHost(); Assert.state(serviceName != null, "Request URI does not contain a valid hostname: " + originalUri); return (ClientHttpResponse)this.loadBalancer.execute(serviceName, this.requestFactory.createRequest(request, body, execution)); &#125;&#125; 可以通过LoadBalancerClient来获取对应的服务信息 java12345678@Autowiredprivate LoadBalancerClient client;@GetMapping("/choose")public Object chooseUrl()&#123; ServiceInstance instance = client.choose("provider"); return instance;&#125; ​ Ribbon的饥饿加载在进行服务调用的时候，如果网络情况不好，第一次调用会超时。Ribbon 的客户端是在第一次请求的时候初始化的，当超时时间比较短的时候，客户端初始化时间加上接口请求时间，就会第一次调用超时。这种问题的解决方法是Ribbon 的饥饿加载 yaml1234ribbon: eager-load: enabled: true clients: provider 属性说明： ​ ribbon.eager-load-enabled: 开启ribbon的饥饿加载模式 ​ ribbon.eager-load.clients: 指定需要饥饿加载的服务名(即需求调用的服务)，有多个需要用逗号分隔 自定义Ribbon的负载策略 通过实现IRule接口可以自定义负载策略 java123456789101112131415161718192021222324252627282930package com.crescentd.config;import com.netflix.loadbalancer.ILoadBalancer;import com.netflix.loadbalancer.IRule;import com.netflix.loadbalancer.Server;import java.util.List;public class MyRule implements IRule &#123; private ILoadBalancer iLoadBalancer; @Override public Server choose(Object o) &#123; List&lt;Server&gt; servers = iLoadBalancer.getAllServers(); for (Server server:servers)&#123; System.out.println("自定义负载策略："+server.getHostPort()); &#125; return servers.get(0); &#125; @Override public void setLoadBalancer(ILoadBalancer iLoadBalancer) &#123; this.iLoadBalancer = iLoadBalancer; &#125; @Override public ILoadBalancer getLoadBalancer() &#123; return this.iLoadBalancer; &#125;&#125; 添加配置信息 yaml1234provider: ribbon: NFLoadBalancerRuleClassName: com.crescentd.config.MyRule 配置说明： ​ provider: 服务提供者在注册中心注册的服务名 ​ NFLoadBalancerRuleClassName: 指定负载均衡器的实现类 ​ 注：以上也是配置负载均衡策略的方式]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈spring cloud 上]]></title>
    <url>%2Fspringcloud%2F%E6%B5%85%E8%B0%88springcloud%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[浅谈spring cloud上创建注册中心 创建maven工程（不使用任何模板），添加依赖 xml1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.7.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Finchley.SR2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 在父工程下创建Module、pom.xml xml1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在子工程resources目录下创建配置文件application.yml(或 .properties) 、添加eureka配置 Code12345678server: port: 8761eureka: client: register-with-eureka: false fetch-registry: false service-url: defaultZone: http://localhost:8761/eureka/ 属性说明 ​ eureka.client.register-with-eureka: 是否将当前的eureka server服务作为客户端进行注册 ​ eureka.client.fecth.registry: 是否获取其他eureka server服务的数据 ​ eureka.client.service-url.defaultZone: 注册中心的访问地址 创建启动类 java1234567891011121314package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaServerApplication.class,args); &#125;&#125; 注解说明: ​ @SpringBootApplication: 声明该类是Spring Boot服务的入口 ​ @EnableEurekaServer: 声明该类是一个Eureka Server微服务，提供服务注册和发现功能，即注册中心 访问http://localhost:8761 创建 Eureka Client 在父目录下新建Module、Pom.xml xml1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件application.yml、添加Eureka Client相关配置 Code123456789101112server: port: 8010spring: application: name: providereureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 属性说明： ​ spring.application.name: 当前服务注册在Eureka Server上的名称 ​ eureka.client.service-url.defaultZone: 注册中心的访问地址 ​ eureka.instace.prefer-ip-address: 是否将当前服务的IP注册到Eureka Server 创建启动类 java123456789101112package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class ProviderApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderApplication.class,args); &#125;&#125; 首先启动注册中心Eureka Server 、 再启动服务提供者Eureka Client，访问http://localhost:8761/ 在Eureka Client中编写业务代码entity 、repository 、controller entity java1234567891011121314package com.crescentd.entity;import lombok.AllArgsConstructor;import lombok.Data;import lombok.NoArgsConstructor;@Data@AllArgsConstructor@NoArgsConstructorpublic class Student &#123; private long id; private String name; private int age;&#125; repository java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.crescentd.repository;import com.crescentd.entity.Student;import java.util.Collection;public interface StudentRepository &#123; public Collection&lt;Student&gt; findAll(); public Student findById(long id); public void saveOrUpdate(Student student); public void delete(long id);&#125;package com.crescentd.repository.impl;import com.crescentd.entity.Student;import com.crescentd.repository.StudentRepository;import org.springframework.stereotype.Repository;import java.util.Collection;import java.util.HashMap;import java.util.Map;@Repositorypublic class StudentRepositoryImpl implements StudentRepository &#123; private static Map&lt;Long,Student&gt; studentMap; static &#123; studentMap = new HashMap&lt;&gt;(); studentMap.put(1L,new Student(1L,"ysity",24)); studentMap.put(2L,new Student(2L,"wwy",24)); studentMap.put(3L,new Student(3L,"ytisy",24)); &#125; @Override public Collection&lt;Student&gt; findAll() &#123; return studentMap.values(); &#125; @Override public Student findById(long id) &#123; return studentMap.get(id); &#125; @Override public void saveOrUpdate(Student student) &#123; studentMap.put(student.getId(),student); &#125; @Override public void delete(long id) &#123; studentMap.remove(id); &#125;&#125; controller java1234567891011121314151617181920212223242526272829303132333435363738394041package com.crescentd.controller;import com.crescentd.entity.Student;import com.crescentd.repository.StudentRepository;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import java.util.Collection;@RestController@RequestMapping("/student")public class StudentHandle &#123; @Autowired private StudentRepository studentRepository; @GetMapping("/findAll") public Collection&lt;Student&gt; findAll()&#123; return studentRepository.findAll(); &#125; @GetMapping("/findById/&#123;id&#125;") public Student findById(@PathVariable("id") long id)&#123; return studentRepository.findById(id); &#125; @PostMapping("/save") public void save(@RequestBody Student student)&#123; studentRepository.saveOrUpdate(student); &#125; @PutMapping("/update") public void update(@RequestBody Student student)&#123; studentRepository.saveOrUpdate(student); &#125; @DeleteMapping("/deleteByid/&#123;id&#125;") public void deleteById(@PathVariable("id") long id)&#123; studentRepository.delete(id); &#125;&#125; RestTemplate的使用 什么是RestTemplate? RestTemplate是spring 框架提供的基于REST的服务组件，底层是对HTTP请求及响应进行了封装，提供了很多访问REST服务的方法，可以简化代码开发 使用RestTemplate 创建Maven工程，POM文件如下： xml1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;parent&gt; &lt;artifactId&gt;pispringcloud&lt;/artifactId&gt; &lt;groupId&gt;com.crescentd&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;resttemplate&lt;/artifactId&gt;&lt;/project&gt; 注：在父工程Pom.xml中已经引入了相关spring依赖，在这里可以直接调用 创建启动类 java12345678910111213141516171819package com.crescentd;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.context.annotation.Bean;import org.springframework.web.client.RestTemplate;@SpringBootApplicationpublic class RestTemplateApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RestTemplateApplication.class,args); &#125; @Bean public RestTemplate restTemplate()&#123; return new RestTemplate(); &#125;&#125; 在启动类中创建restTemplate方法，返回RestTemplate实例，并将其注入IOC容器中 创建实体类 将Eureka Client中的entity复制到com.crescentd目录下 创建controller java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556package com.crescentd.controller;import com.crescentd.entity.Student;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.*;import org.springframework.web.client.RestTemplate;import java.util.Collection;@RestController@RequestMapping("/rest")public class RestTemplateController &#123; @Autowired private RestTemplate restTemplate; @GetMapping("/findAll") public Collection&lt;Student&gt; findAll()&#123; return restTemplate.getForEntity("http://localhost:8010/student/findAll",Collection.class).getBody(); &#125; @GetMapping("/findAll2") public Collection&lt;Student&gt; findAll2()&#123; return restTemplate.getForObject("http://localhost:8010/student/findAll",Collection.class); &#125; @GetMapping("/findById/&#123;id&#125;") public Student findById(@PathVariable("id") long id)&#123; return restTemplate.getForEntity("http://localhost:8010/student/findById/&#123;id&#125;",Student.class,id).getBody(); &#125; @GetMapping("/findById2/&#123;id&#125;") public Student findById2(@PathVariable("id") long id)&#123; return restTemplate.getForObject("http://localhost:8010/student/findById/&#123;id&#125;",Student.class,id); &#125; @PostMapping("/save") public void save(@RequestBody Student student)&#123; restTemplate.postForEntity("http://localhost:8010/student/save",student,null).getBody(); &#125; @PostMapping("/save2") public void save2(@RequestBody Student student)&#123; restTemplate.postForObject("http://localhost:8010/student/save",student,null); &#125; @PutMapping("/update") public void update(@RequestBody Student student)&#123; restTemplate.put("http://localhost:8010/student/update",student); &#125; @DeleteMapping("/delete/&#123;id&#125;") public void deleteById(@PathVariable("id") long id)&#123; restTemplate.delete("http://localhost:8010/student/deleteById/&#123;id&#125;",id); &#125;&#125; getForObject 返回的是ResponseEntity，需要getBody()方法获取实体信息，而getForObject返回的是个泛型 依次启动注册中心Eureka Server、服务提供 方Eureka Client、服务调用方RestTemplate，访问http://localhost:8080/rest/findAll ，同理其他接口调用类似 服务消费者Consumer 创建Maven工程、添加Pom.xml依赖 xml1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建配置文件application.yml yml1234567891011server: port: 8020 spring: application: name: consumer eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: true 之后步骤与RestTemplate相同 服务网关Zuul 创建Maven工程，添加pom依赖 xml12345678910111213&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;version&gt;2.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 添加配置文件application.yml yml123456789101112server: port: 8030 spring: application: name: gateway eureka: client: service-url: defaultZone: http://localhost:8761/eureka/ zuul: routes: provider: /p/** 属性介绍： ​ zuul.routes.provider : 给服务提供者provider设置映射 创建启动类 java1234567891011121314package com.crescentd; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.EnableAutoConfiguration; import org.springframework.cloud.netflix.zuul.EnableZuulProxy; @EnableZuulProxy @EnableAutoConfiguration public class ZuulApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ZuulApplication.class,args); &#125; &#125; 注解说明： ​ @EnableZuulProxy: 包含了@EnableZuulServer ，设置该类是网关的启动类 ​ @EnableAutoConfiguration: 可以帮助spring boot 应用将所有符合条件的@Configuration 配置加载到当 前spring boot创建并使用的IOC容器中 依次启动注册中心、服务提供者、网关，访问http://localhost:8030/p/student/findAll ，其中 http://localhost:8030/p 就相当于服务提供者的地址: http://localhost:8010/ Zuul 自带了负载均衡的功能 修改服务提供者eureka client 的controller ，在启动eureka client 后，修改配置文件的端口为8011，在同目录下复制启动类后，将复制的启动类启动，就会读取8011的端口。用这种方式模拟注册中心存在两个服务提供者。多次访问http://localhost:8030/p/student/index 会发现8010和8011交替出现，也就证明网关提供负载均衡的功能 java1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com.crescentd.controller; import com.crescentd.entity.Student; import com.crescentd.repository.StudentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; import java.util.Collection; @RestController @RequestMapping("/student") public class StudentHandle &#123; @Autowired private StudentRepository studentRepository; @Value("$&#123;server.port&#125;") private String port; @GetMapping("/findAll") public Collection&lt;Student&gt; findAll()&#123; return studentRepository.findAll(); &#125; @GetMapping("/findById/&#123;id&#125;") public Student findById(@PathVariable("id") long id)&#123; return studentRepository.findById(id); &#125; @PostMapping("/save") public void save(@RequestBody Student student)&#123; studentRepository.saveOrUpdate(student); &#125; @PutMapping("/update") public void update(@RequestBody Student student)&#123; studentRepository.saveOrUpdate(student); &#125; @DeleteMapping("/deleteById/&#123;id&#125;") public void deleteById(@PathVariable("id") long id)&#123; studentRepository.delete(id); &#125; @GetMapping("/index") public String index()&#123; return "当前端口是:"+this.port; &#125; &#125;]]></content>
      <categories>
        <category>springcloud</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记录前端js路径跳转问题]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF-web%2F%E8%AE%B0%E5%BD%95%E5%89%8D%E7%AB%AFjs%E8%B7%AF%E5%BE%84%E8%B7%B3%E8%BD%AC%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录前端js路径跳转问题在工作中处理前端路径跳转问题的时候碰到在a标签 中windows.location.replace 无法跳转的问题。 经试验：window.location.href 和location.href 同样不能跳转。 解决方案 a标签的href属性设置锚点 &lt;a href=&quot;#&quot; class=&quot;goBack&quot; onclick=&#39;event()&#39;&gt;&lt;/a&gt; 在事件后加上return false; (在事件内部加是无效的) &lt;a href=&quot;javascript:;&quot; class=&quot;goBack&quot; onclick=&#39;event();return false;&#39;&gt;&lt;/a&gt;]]></content>
      <categories>
        <category>前端,web</category>
      </categories>
      <tags>
        <tag>javascript,web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端样式]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2F%E5%89%8D%E7%AB%AF%E6%A0%B7%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[样式 背景 （不可被继承） 背景色 background-color 颜色单词 red，blue，black等 #000000 或者缩写 #000 (缩写需要每相邻的两位数字相同) 值为0-F 16进制数字 rgb(0,0,0), rgba(0,0,0,0) 值为0-255， a为透明度，值为0-1，四个值都可使用百分数 背景图片 background-image url(图片路径) 背景重复 background-repeat 水平平铺 repeat-x 垂直平铺 repeat-y 不平铺 no-repeat 背景定位 background-position top,right,bottom,left,center 百分比（以图片中心和容器中心做对比） 长度值（以图片左上角和容器左上角做对比） 背景关联 background-attachment scroll 默认值，背景图片随滚动条滚动 fixed 背景图片不随滚动条滚动 同时声明全部属性，顺序如下background: 背景色 背景图片 背景重复 背景关联 背景定位; 文本 颜色 color 背景颜色 background-color 行高 line-height （设置为100%可实现文本垂直居中） 缩进文本 text-indent 水平对齐 text-alignt left，center，right 两端对齐 justify 字(单词)间隔 word-spacing 字母间隔 letter-spacing 字符转换 text-transform 大写 uppercase 小写 lowercase 首字母大写 capitalize 文本装饰 text-decoration 下划线 underline 上划线 overline 删除线 line-through 空白符处理 white-space pre 不合并空白符，换行符，不允许自动换行 nowrap 合并空白符，换行符，不允许自动换行 pre-wrap 不合并空白符，换行符，允许自动换行 pre-line 合并空白符，保留换行符， 允许自动换行 normal 合并空白符，换行符, 允许自动换行 字体 字体 font-family 可设置多个字体防止用户本地没有对应的字体 字体风格 font-style 斜体 italic 文本倾斜 oblique（和斜体没什么区别） 字体变形 font-variant small-caps 可让小写字母变大写并保持小写的大小 字体加粗 font-weight 字体大小 font-size 默认16px 链接 未访问的样式 a:link 已访问的样式 a:visited 鼠标指针悬停样式 a:hover 被点击时样式 a:active上述四种样式排序规则 列表 列表项标志: list-style-type 列表项图像: list-style-image]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pev's problem]]></title>
    <url>%2Fproblem-%E5%89%8D%E7%AB%AF%2Fpev-s-problem%2F</url>
    <content type="text"><![CDATA[记录一下生产中所遇到的问题new Date(time)在iOS真机环境下的兼容性问题new Date(xxxx-xx-xx xx:xx:xx) 在iOS下被认为是错误的使用方式，通过该对象创建的日期返回的是valid Date ，在iOS下使用new Date() 需要特定的事件格式 ：xxxx/xx/xx xx:xx:xx 。已下记录一下更改的方式: javascript123let time = 2019-09-20 12:00:00let time_ios = new Date(time) //在iOS下出错let time_change = new Date(time.replace(/-/g,'/')) //正确 补充当值为NaN 时，使用jquery 的html(NaN) 方法和document.getElementBy[*].innerHTML = NaN 赋值时在页面上不会显示NaN 。使用jquery的text(NaN) 方法则会。上面iOS下的时间格式问题用错会产生NaN。 javascript123$('#time').html(NaN) //页面不会显示 document.getElementById('time').innerHTML = NaN //同上$('#time').text(NaN) //页面显示]]></content>
      <categories>
        <category>problem,前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript中LHS和RHS]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2Fjavascript%E4%B8%ADLHS%E5%92%8CRHS%2F</url>
    <content type="text"><![CDATA[JS中的LHS和RHS什么是LHS和RHS两者都是JS引擎存在的查询方式: LHS（Left-hand Side）:left是指“=”号的左边，意思是要给查询得到的这个变量赋值，比如要吧1付给a变量，要先查询a是否存在，这时候用的就是LHS查询 RHS（Right-hand Side）:right指的是“=”号右边，意思是要获取某个变量的值，比如打印a变量，console.log(a);js引擎要去查询这个变量是否存在，得到变量只想的值，这个时候用的就是RHS查询 javascript12345function foo(a)&#123; var b = a; rerurn a + b; &#125;var c = foo(1); 以上代码共有三次LHS和四次RHS查询： var c = foo(1)，需要对变量 c 赋值所以进行一次LHS查询，然后将 foo(1) 赋给 c ，foo(1) 的值从哪来呢，需要查找 foo(1) 的值，此时就对 foo(1) 进行一次RHS查询 隐含赋值操作，foo(1) 将实参 1 传递给 function foo(a){……} 函数的形参 a ，a 在赋值操作的左侧，对 a 进行一次LHS查询 var b = a，需要对变量 b 赋值所以进行一次LHS查询，b 的值将从 a 来 ，a 的值从哪来呢，需要查找 a 的值，此时就对 a 进行一次RHS查询 return a+b 中，需要找到 a 与 b 的值的来源，a 与 b 都在赋值操作的右侧，才能得到 a+b 的值，所以对 a 与 b 都是进行RHS查询引用。 NoticeLHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是”=”赋值操作符的左侧或右侧。 当变量出现在赋值操作的左侧时进行LHS查询，出现在赋值操作的右侧时进行RHS查询 RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。 如果查找目的是对变量进行赋值，那么就使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。（即可简单理解成”赋值操作的目标是谁（LHS）”以及”谁是赋值操作的源头(RHS)”） 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 这就说明了为什么不加var时定义的是全局变量。 关于报错LHS查询比较松散，如果查询不到，就会创建一个全局的，不会抛出异常。RHS查询比较严格，如果查询不到的话就会抛出异常，因为你要获取某个变量指向的值，可是根本就没有那个变量，这个时候已经超出它的能力范围，所以只能抛出异常 如下代码： javascript12345function foo(a)&#123; console.log(a+b) b=a&#125;foo(1) b=a 不是变量声明，编译过程中不会将其提前，也就是说，b是一个未声明的变量，在任何相关作用域中都无法找到，因此在执行a+b时RHS查询在所有嵌套的作用域中都遍寻不到所需的变量，因此就会抛出 Uncaught ReferenceError: b is not defined这样一个错误 JS引擎具体工作过程如下： 在当前作用域中查找名为foo的函数(RHS) 进入 foo函数体，首先 JS 引擎在执行前会对整个函数的声明部分做完整分析（包括局部变量），从而确定变量的作用域（js引擎读取一段js代码，首先执行预解析，就是逐行读取js代码，寻找全局变量和全局函数，遇到全局变量，把变量的值变为undefind,存在内存中，遇到全局函数，直接存在内存中，这个过程如果发现语法错误，预解析终止）。因此第一步搜集变量，发现在函数作用域中这里只有作为参数的局部变量 a，提升到作用域顶部。 将 1 赋值给 a (a = 1,LHS) 查找 console 对象（RHS），发现是内置函数，在 console 对象下查找 log 函数（RHS） 在当前作用域中查找变量 a，并获取 a 的值为（a = 1, RHS） 在当前作用域中查找变量 b，未找到该变量 将 a 和 b 的查找结果传入 console.log() 函数，打印结果（ b 未定义，抛出 Uncaught ReferenceError:b is not defined） 为什么要区分LHS和RHS这两种不同的引用方式的在对没有声明的变量的处理上是不同的。而这个不同之处对于我们编写代码和分析JS引擎报的错误是很有用处的。 当对一个变量执行RHS查询时，如果遍历该变量所在处的词法作用域未能找到这个变量，JS引擎就会抛出 ReferenceError 错误如果成功查询到了这个变量，但是对这个变量执行不合理操作，比如对一个非数组的变量执行下标取值，JS引擎就会抛出 TypeError 错误 当对一个变量执行LHS查询时，同样在遍历作用域后无法找到该变量，在非ES5的严格模式下，系统就会自动在全局作用域中创建一个同名变量，并将引用转移到该新建的全局变量中。而在ES5的严格模式下，LHS查询失败时JS引擎会抛出一个同RHS一样的 ReferenceError 错误。 写在最后看到这里应该就能理解为什么使用未定义的变量有时报错有时正常。如果是访问对象的属性就不存在LHS和RHS查询了，找不到就返回 undefined。对这些有更加深刻的理解无论是对JS执行过程本身还是分析抛出的异常都是有好处的]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德地图Js的使用]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%2F%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEJs%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在H5中使用高德地图使用前准备1.注册开发者账号 建议使用个人开发者，高德提供有限免费的Api调用次数 2.创建应用并添加key 正式开始高德Api在H5中的使用初始化地图在H5中创建一个地图首先使用&lt;script&gt;&lt;/script&gt; 引入高德的Api key. 接着创建一个div : div#container .最后在js文件中新建一个地图对象AMap 即可. javascript123456789&lt;div id="container"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=160cab8ad6c50752175d76e61ef92c50&amp;plugin=AMap.Geolocation"&gt;&lt;/script&gt;&lt;script&gt; const map = new AMap.Map('container', &#123; //这里的container是创建的div的id resizeEnable: true, //是否监控地图容器尺寸变化 zoom: 14, //初始化地图层级 层级从大到小 地图显示从细到广 &#125;);&lt;/script&gt; 定位功能在项目中使用最多的就是定位功能。地图的初始化加载定位只能获取到城市级别，但往往我们需要的是精准定位，对于H5而言想要拿到具体的位置就需要浏览器定位。高德js 提供AMap.Geolocation 插件来实现。 javascript12345678910111213141516171819202122232425&lt;script&gt; AMap.plugin('AMap.Geolocation', function() &#123; let geolocation = new AMap.Geolocation(&#123; enableHighAccuracy: true, //是否使用高精度定位，默认:true timeout: 10000, //超过10秒后停止定位，默认：无穷大 maximumAge: 60000, //定位结果缓存0毫秒，默认：0 convert: true, //自动偏移坐标，偏移后的坐标为高德坐标，默认：true showButton: true, //显示定位按钮，默认：true buttonPosition: 'RB', //定位按钮停靠位置，默认：'LB'，左下角 buttonOffset: new AMap.Pixel(10, 20),//定位按钮与设置的停靠位置的偏移量 showMarker: true, //定位成功后在定位到的位置显示点标记，默认：true showCircle: false, //定位成功后用圆圈表示定位精度范围，默认：true panToLocation: true, //定位成功后将定位到的位置作为地图中心点，默认：true zoomToAccuracy:false, //定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false &#125;); map.addControl(geolocation); geolocation.getCurrentPosition(function(status, result) &#123; if (status == 'complete') &#123; onsuccess(); //定位成功的回调函数 按自己需求自定义实现 &#125; else &#123; onError(); //定位失败的回调函数 &#125; &#125;);&#125;);&lt;/script&gt; 注 ：在很多情况下使用精准定位（getCurrentPosition()）是无法拿到位置的。下面贴出高德官方给出的定位失败原因： 较为多见的定位失败问题为get geolocation failed 和 get geolocation time out ,对于这两个问题，在只是测试情况下可以使用火狐浏览器 并将其内容安全策略设置CSP 改为false。具体操作为在搜索栏输入about:config 后再在搜索框中输入csp 即可。 至于问题geolocation permission denied ，需升级站点到HTTPS 则 可以自行搜索 tomcat的https配置即可解决 导航线路规划高德js的线路规划有四种策略(驾车策略)： AMap.DrivingPolicy.LEAST_TIME 最快捷模式 AMap.DrivingPolicy.LEAST_FEE 最经济模式 AMap.DrivingPolicy.LEAST_DISTANCE 最短距离模式 AMap.DrivingPolicy.REAL_TRAFFIC 考虑实时路况 要使用不同的策略，目前好像只有创建多个驾车对象 ，设置不同的策略 javascript1234567AMap.plugin(["AMap.Driving"], function() &#123; let drivingOption = &#123; policy:AMap.DrivingPolicy.LEAST_TIME, //时间最短 map:map, // 初始化的地图 &#125;; let driving = new AMap.Driving(drivingOption); //构造驾车导航类&#125;);]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>高德地图</tag>
      </tags>
  </entry>
</search>
