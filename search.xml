<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[javascript中LHS和RHS]]></title>
    <url>%2Fundefined%2Fjavascript%E4%B8%ADLHS%E5%92%8CRHS%2F</url>
    <content type="text"><![CDATA[JS中的LHS和RHS什么是LHS和RHS两者都是JS引擎存在的查询方式: LHS（Left-hand Side）:left是指“=”号的左边，意思是要给查询得到的这个变量赋值，比如要吧1付给a变量，要先查询a是否存在，这时候用的就是LHS查询 RHS（Right-hand Side）:right指的是“=”号右边，意思是要获取某个变量的值，比如打印a变量，console.log(a);js引擎要去查询这个变量是否存在，得到变量只想的值，这个时候用的就是RHS查询 12345function foo(a)&#123; var b = a; rerurn a + b; &#125;var c = foo(1); 以上代码共有三次LHS和四次RHS查询： var c = foo(1)，需要对变量 c 赋值所以进行一次LHS查询，然后将 foo(1) 赋给 c ，foo(1) 的值从哪来呢，需要查找 foo(1) 的值，此时就对 foo(1) 进行一次RHS查询 隐含赋值操作，foo(1) 将实参 1 传递给 function foo(a){……} 函数的形参 a ，a 在赋值操作的左侧，对 a 进行一次LHS查询 var b = a，需要对变量 b 赋值所以进行一次LHS查询，b 的值将从 a 来 ，a 的值从哪来呢，需要查找 a 的值，此时就对 a 进行一次RHS查询 return a+b 中，需要找到 a 与 b 的值的来源，a 与 b 都在赋值操作的右侧，才能得到 a+b 的值，所以对 a 与 b 都是进行RHS查询引用。 NoticeLHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是”=”赋值操作符的左侧或右侧。 当变量出现在赋值操作的左侧时进行LHS查询，出现在赋值操作的右侧时进行RHS查询 RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。 如果查找目的是对变量进行赋值，那么就使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。（即可简单理解成”赋值操作的目标是谁（LHS）”以及”谁是赋值操作的源头(RHS)”） 作用域嵌套当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。遍历嵌套作用域链的规则很简单：引擎从当前的执行作用域开始查找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。 这就说明了为什么不加var时定义的是全局变量。 关于报错LHS查询比较松散，如果查询不到，就会创建一个全局的，不会抛出异常。RHS查询比较严格，如果查询不到的话就会抛出异常，因为你要获取某个变量指向的值，可是根本就没有那个变量，这个时候已经超出它的能力范围，所以只能抛出异常 如下代码： 12345function foo(a)&#123; console.log(a+b) b=a&#125;foo(1) b=a 不是变量声明，编译过程中不会将其提前，也就是说，b是一个未声明的变量，在任何相关作用域中都无法找到，因此在执行a+b时RHS查询在所有嵌套的作用域中都遍寻不到所需的变量，因此就会抛出 Uncaught ReferenceError: b is not defined这样一个错误 JS引擎具体工作过程如下： 在当前作用域中查找名为foo的函数(RHS) 进入 foo函数体，首先 JS 引擎在执行前会对整个函数的声明部分做完整分析（包括局部变量），从而确定变量的作用域（js引擎读取一段js代码，首先执行预解析，就是逐行读取js代码，寻找全局变量和全局函数，遇到全局变量，把变量的值变为undefind,存在内存中，遇到全局函数，直接存在内存中，这个过程如果发现语法错误，预解析终止）。因此第一步搜集变量，发现在函数作用域中这里只有作为参数的局部变量 a，提升到作用域顶部。 将 1 赋值给 a (a = 1,LHS) 查找 console 对象（RHS），发现是内置函数，在 console 对象下查找 log 函数（RHS） 在当前作用域中查找变量 a，并获取 a 的值为（a = 1, RHS） 在当前作用域中查找变量 b，未找到该变量 将 a 和 b 的查找结果传入 console.log() 函数，打印结果（ b 未定义，抛出 Uncaught ReferenceError:b is not defined） 为什么要区分LHS和RHS这两种不同的引用方式的在对没有声明的变量的处理上是不同的。而这个不同之处对于我们编写代码和分析JS引擎报的错误是很有用处的。 当对一个变量执行RHS查询时，如果遍历该变量所在处的词法作用域未能找到这个变量，JS引擎就会抛出 ReferenceError 错误如果成功查询到了这个变量，但是对这个变量执行不合理操作，比如对一个非数组的变量执行下标取值，JS引擎就会抛出 TypeError 错误 当对一个变量执行LHS查询时，同样在遍历作用域后无法找到该变量，在非ES5的严格模式下，系统就会自动在全局作用域中创建一个同名变量，并将引用转移到该新建的全局变量中。而在ES5的严格模式下，LHS查询失败时JS引擎会抛出一个同RHS一样的 ReferenceError 错误。 写在最后看到这里应该就能理解为什么使用未定义的变量有时报错有时正常。如果是访问对象的属性就不存在LHS和RHS查询了，找不到就返回 undefined。对这些有更加深刻的理解无论是对JS执行过程本身还是分析抛出的异常都是有好处的]]></content>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德地图Js的使用]]></title>
    <url>%2Fundefined%2F%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEJs%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在H5中使用高德地图使用前准备1.注册开发者账号 建议使用个人开发者，高德提供有限免费的Api调用次数 2.创建应用并添加key 正式开始高德Api在H5中的使用初始化地图在H5中创建一个地图首先使用&lt;script&gt;&lt;/script&gt; 引入高德的Api key. 接着创建一个div : div#container .最后在js文件中新建一个地图对象AMap 即可. 123456789&lt;div id="container"&gt;&lt;/div&gt;&lt;script type="text/javascript" src="https://webapi.amap.com/maps?v=1.4.15&amp;key=160cab8ad6c50752175d76e61ef92c50&amp;plugin=AMap.Geolocation"&gt;&lt;/script&gt;&lt;script&gt; const map = new AMap.Map('container', &#123; //这里的container是创建的div的id resizeEnable: true, //是否监控地图容器尺寸变化 zoom: 14, //初始化地图层级 层级从大到小 地图显示从细到广 &#125;);&lt;/script&gt; 定位功能在项目中使用最多的就是定位功能。地图的初始化加载定位只能获取到城市级别，但往往我们需要的是精准定位，对于H5而言想要拿到具体的位置就需要浏览器定位。高德js 提供AMap.Geolocation 插件来实现。 12345678910111213141516171819202122232425&lt;script&gt; AMap.plugin('AMap.Geolocation', function() &#123; let geolocation = new AMap.Geolocation(&#123; enableHighAccuracy: true, //是否使用高精度定位，默认:true timeout: 10000, //超过10秒后停止定位，默认：无穷大 maximumAge: 60000, //定位结果缓存0毫秒，默认：0 convert: true, //自动偏移坐标，偏移后的坐标为高德坐标，默认：true showButton: true, //显示定位按钮，默认：true buttonPosition: 'RB', //定位按钮停靠位置，默认：'LB'，左下角 buttonOffset: new AMap.Pixel(10, 20),//定位按钮与设置的停靠位置的偏移量 showMarker: true, //定位成功后在定位到的位置显示点标记，默认：true showCircle: false, //定位成功后用圆圈表示定位精度范围，默认：true panToLocation: true, //定位成功后将定位到的位置作为地图中心点，默认：true zoomToAccuracy:false, //定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false &#125;); map.addControl(geolocation); geolocation.getCurrentPosition(function(status, result) &#123; if (status == 'complete') &#123; onsuccess(); //定位成功的回调函数 按自己需求自定义实现 &#125; else &#123; onError(); //定位失败的回调函数 &#125; &#125;);&#125;);&lt;/script&gt; 注 ：在很多情况下使用精准定位（getCurrentPosition()）是无法拿到位置的。下面贴出高德官方给出的定位失败原因： 较为多见的定位失败问题为get geolocation failed 和 get geolocation time out ,对于这两个问题，在只是测试情况下可以使用火狐浏览器 并将其内容安全策略设置CSP 改为false。具体操作为在搜索栏输入about:config 后再在搜索框中输入csp 即可。 至于问题geolocation permission denied ，需升级站点到HTTPS 则 可以自行搜索 tomcat的https配置即可解决 导航线路规划高德js的线路规划有四种策略(驾车策略)： AMap.DrivingPolicy.LEAST_TIME 最快捷模式 AMap.DrivingPolicy.LEAST_FEE 最经济模式 AMap.DrivingPolicy.LEAST_DISTANCE 最短距离模式 AMap.DrivingPolicy.REAL_TRAFFIC 考虑实时路况 要使用不同的策略，目前好像只有创建多个驾车对象 ，设置不同的策略 1234567AMap.plugin(["AMap.Driving"], function() &#123; let drivingOption = &#123; policy:AMap.DrivingPolicy.LEAST_TIME, //时间最短 map:map, // 初始化的地图 &#125;; let driving = new AMap.Driving(drivingOption); //构造驾车导航类&#125;);]]></content>
      <tags>
        <tag>AMap,AMap.Marker,AMap.geolocation,AMap.PlaceSearch</tag>
      </tags>
  </entry>
</search>
